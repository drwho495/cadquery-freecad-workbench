import FreeCAD
import Part

def createCodeFeature(doc, name="CodeFeature"):
    if not doc:
        FreeCAD.Console.PrintError("No active document to add CodeFeature.\n")
        return None

    obj = doc.addObject("Part::FeaturePython", name)
    if not obj:
        FreeCAD.Console.PrintError(f"Failed to create Part::Feature with name {name}.\n")
        return None

    obj.addProperty("App::PropertyString", "MacroFilename", "CodeObject", "Filename of the .FCMacro (e.g., MyMacro.FCMacro).")
    obj.addProperty("App::PropertyPath", "MacroDir", "CodeObject", "Directory containing the macro file. Leave empty to use document's dir or user macro dir.")
    obj.addProperty("App::PropertyString", "GeneratedObjectLabel", "CodeObject", "Optional label for the object generated by the code.")
    obj.MacroFilename = ""
    try:
        defaultMacroUserPath = FreeCAD.ParamGet("User parameter:BaseApp/Preferences/Macro").GetString("MacroPath")
        obj.MacroDir = defaultMacroUserPath
    except Exception:
        obj.MacroDir = ""
    obj.GeneratedObjectLabel = name

    FreeCAD.Console.PrintMessage(f"Created CodeFeature: {obj.Name} with Label {obj.Label}\n")
    CodeFeatureProxy(obj)
    if FreeCAD.GuiUp:
        ViewProviderCodeFeature(obj.ViewObject)
    doc.recompute() # Recompute to make the new object visible and properties available
    return obj

def executeCodeFeature(featureObject):
    if not hasattr(featureObject, "MacroFilename"):
        try:
            featureObject.addProperty("App::PropertyString", "MacroFilename", "CodeObject", "Filename of the .FCMacro (e.g., MyMacro.FCMacro).")
            featureObject.MacroFilename = "" # Initialize
            FreeCAD.Console.PrintWarning(f"Added missing MacroFilename property to {featureObject.Name}. Please set its value.\n")
        except Exception as e:
            FreeCAD.Console.PrintError(f"Could not add MacroFilename property to {featureObject.Name}: {e}\n")
            return
            
    if not hasattr(featureObject, "MacroDir"):
        try:
            featureObject.addProperty("App::PropertyPath", "MacroDir", "CodeObject", "Directory containing the macro file. Leave empty or set to user/doc default.")
            try:
                defaultMacroUserPath = FreeCAD.ParamGet("User parameter:BaseApp/Preferences/Macro").GetString("MacroPath")
                featureObject.MacroDir = defaultMacroUserPath
            except:
                featureObject.MacroDir = ""
            FreeCAD.Console.PrintWarning(f"Added missing MacroDir property to {featureObject.Name}. Initialized to '{featureObject.MacroDir}'. Please verify/set its value.\n")
        except Exception as e:
            FreeCAD.Console.PrintError(f"Could not add MacroDir property to {featureObject.Name}: {e}\n")
            return

    macroFilename = featureObject.MacroFilename
    macroDir = featureObject.MacroDir

    if not macroFilename:
        FreeCAD.Console.PrintError(f"MacroFilename property is empty for {featureObject.Name}. Please specify a .FCMacro filename.\n")
        return

    import os 
    fullMacroPath = ""

    if os.path.isabs(macroFilename):
        fullMacroPath = macroFilename

        FreeCAD.Console.PrintMessage(f"Interpreting MacroFilename '{macroFilename}' as an absolute path.\n")
    elif macroDir and os.path.isabs(str(macroDir)):
        fullMacroPath = os.path.join(str(macroDir), macroFilename)

        FreeCAD.Console.PrintMessage(f"Using specified absolute MacroDir '{str(macroDir)}' + Filename: {fullMacroPath}\n")
    elif macroDir: 
        fullMacroPath = os.path.join(str(macroDir), macroFilename)

        FreeCAD.Console.PrintMessage(f"Using specified MacroDir '{str(macroDir)}' (may be relative) + Filename: {fullMacroPath}\n")
    
    if fullMacroPath and os.path.exists(fullMacroPath):
        exec(open(fullMacroPath).read())
# --- FreeCAD FeaturePython structure (if we were to make it a full FeaturePython object) ---
# This part is more advanced and makes the feature behave more like a native FreeCAD feature,
# with its own icon, properties in the tree, and recomputation logic.

class ViewProviderCodeFeature:
    def __init__(self, vobj):
        vobj.Proxy = self
        self.Object = vobj.Object

    def attach(self, vobj):
        self.Object = vobj.Object
        self.ViewObject = vobj
        return

    def updateData(self, fp, prop):
        pass

    def getDisplayModes(self, obj):
        modes = ["Shaded", "Wireframe", "Flat Lines", "Points"]
        return modes

    def setDisplayMode(self, mode):
        return mode

    def claimChildren(self):
        if hasattr(self.Object, "Shape") and self.Object.Shape and not self.Object.Shape.isNull():
            return [self.Object.Shape]
        return []

    def getIcon(self):
        return ""

# For now, we are using a simpler approach of adding properties to a Part::Feature.
# If a more integrated solution is needed, this is the direction to go.

class CodeFeatureProxy:
    def __init__(self, obj):
        self.Object = obj
        obj.Proxy = self

    def execute(self, fp):
        FreeCAD.Console.PrintMessage(f"CodeFeatureProxy.execute for {fp.Label}\n")

        executeCodeFeature(fp)
        return True

    def onChanged(self, fp, prop):
        FreeCAD.Console.PrintMessage(f"Property '{prop}' of {fp.Label} changed.\n")
        
        if prop == "CodeString" or prop == "CodeType" or prop == "GeneratedObjectLabel":
            pass