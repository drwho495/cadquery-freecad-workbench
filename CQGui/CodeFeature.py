import FreeCAD
import Part

# Method that will be used in the macros to update the Shape of a codefeature
part = None

# Move these 4 methods to another files
def getShape(part):
    import cadquery as cq
    from PySide import QtGui

    from io import BytesIO
    brep_stream = BytesIO()

    if isinstance(part, cq.Workplane):
        part.val().exportBrep(brep_stream)
    elif isinstance(part, cq.Shape):
        part.exportBrep(brep_stream)
    elif hasattr(part, "wrapped"):
        from build123d import export_brep

        export_brep(part, brep_stream)
    elif hasattr(part, "part") and hasattr(part.part, "wrapped"):
        from build123d import export_brep

        export_brep(part.part, brep_stream)
    else:
        print("Object type not support for display: ", type(part).__name__)
        return

    brep_string = brep_stream.getvalue().decode('utf-8')
    part_shape = Part.Shape()
    part_shape.importBrepFromString(brep_string)

    return part_shape

def upload_part(newObj):
    global part

    part = newObj


def createCodeFeature(doc, name="CodeFeature"):
    if not doc:
        FreeCAD.Console.PrintError("No active document to add CodeFeature.\n")
        return None

    obj = doc.addObject("Part::FeaturePython", name)
    if not obj:
        FreeCAD.Console.PrintError(f"Failed to create Part::Feature with name {name}.\n")
        return None

    obj.addProperty("App::PropertyString", "MacroFilename", "CodeObject", "Filename of the .FCMacro (e.g., MyMacro.FCMacro).")
    obj.addProperty("App::PropertyPath", "MacroDir", "CodeObject", "Directory containing the macro file. Leave empty to use document's dir or user macro dir.")
    obj.addProperty("App::PropertyString", "GeneratedObjectLabel", "CodeObject", "Optional label for the object generated by the code.")

    obj.MacroFilename = ""
    try:
        defaultMacroUserPath = FreeCAD.ParamGet("User parameter:BaseApp/Preferences/Macro").GetString("MacroPath")
        obj.MacroDir = defaultMacroUserPath
    except Exception:
        obj.MacroDir = ""
    obj.GeneratedObjectLabel = name

    ViewProviderCodeFeature(obj.ViewObject)
    CodeFeatureProxy(obj)

    return obj

def executeCodeFeature(featureObject):
    global part

    if not hasattr(featureObject, "MacroFilename"):
        try:
            featureObject.addProperty("App::PropertyString", "MacroFilename", "CodeObject", "Filename of the .FCMacro (e.g., MyMacro.FCMacro).")
            featureObject.MacroFilename = "" # Initialize
        except Exception as e:
            FreeCAD.Console.PrintError(f"Could not add MacroFilename property to {featureObject.Name}: {e}\n")
            return
            
    if not hasattr(featureObject, "MacroDir"):
        try:
            featureObject.addProperty("App::PropertyPath", "MacroDir", "CodeObject", "Directory containing the macro file. Leave empty or set to user/doc default.")
            try:
                defaultMacroUserPath = FreeCAD.ParamGet("User parameter:BaseApp/Preferences/Macro").GetString("MacroPath")
                featureObject.MacroDir = defaultMacroUserPath
            except:
                featureObject.MacroDir = ""
        except Exception as e:
            FreeCAD.Console.PrintError(f"Could not add MacroDir property to {featureObject.Name}: {e}\n")
            return

    macroFilename = featureObject.MacroFilename
    macroDir = featureObject.MacroDir

    if not macroFilename:
        FreeCAD.Console.PrintError(f"MacroFilename property is empty for {featureObject.Name}. Please specify a .FCMacro filename.\n")
        return

    import os 
    fullMacroPath = ""

    if os.path.isabs(macroFilename):
        fullMacroPath = macroFilename

        FreeCAD.Console.PrintMessage(f"Interpreting MacroFilename '{macroFilename}' as an absolute path.\n")
    elif macroDir and os.path.isabs(str(macroDir)):
        fullMacroPath = os.path.join(str(macroDir), macroFilename)

        FreeCAD.Console.PrintMessage(f"Using specified absolute MacroDir '{str(macroDir)}' + Filename: {fullMacroPath}\n")
    elif macroDir: 
        fullMacroPath = os.path.join(str(macroDir), macroFilename)

        FreeCAD.Console.PrintMessage(f"Using specified MacroDir '{str(macroDir)}' (may be relative) + Filename: {fullMacroPath}\n")
    
    if fullMacroPath and os.path.exists(fullMacroPath):
        exec(open(fullMacroPath).read())

        if part != None:
            featureObject.Shape = getShape(part)
        else:
            FreeCAD.Console.PrintWarning("No part was uploaded!")

class ViewProviderCodeFeature:
    def __init__(self, vobj):
        vobj.Proxy = self
        self.Object = vobj.Object

    def attach(self, vobj):
        self.Object = vobj.Object
        self.ViewObject = vobj
        return

    def updateData(self, fp, prop):
        pass

    def getDisplayModes(self, obj):
        modes = ["Shaded", "Wireframe", "Flat Lines", "Points"]
        return modes

    def setDisplayMode(self, mode):
        return mode

    # def claimChildren(self):
        # if hasattr(self.Object, "Shape") and self.Object.Shape and not self.Object.Shape.isNull():
            # return [self.Object.Shape]
        # return []

    def getIcon(self):
        # Return a custom icon (optional)
        return """
            /* XPM */
            static const char *icon[] = {
            "16 16 2 1",
            "  c None",
            ". c #0000FF",
            "                ",
            "       ..       ",
            "      ....      ",
            "     ......     ",
            "    ........    ",
            "   ..........   ",
            "  ............  ",
            " .............. ",
            " .............. ",
            "  ............  ",
            "   ..........   ",
            "    ........    ",
            "     ......     ",
            "      ....      ",
            "       ..       ",
            "                "
            };
        """
    def __getstate__(self):
        # Called when saving
        return None

    def __setstate__(self, state):
        # Called when restoring
        return None

# For now, we are using a simpler approach of adding properties to a Part::Feature.
# If a more integrated solution is needed, this is the direction to go.

class CodeFeatureProxy:
    def __init__(self, obj):
        self.Object = obj
        obj.Proxy = self

    def execute(self, fp):
        FreeCAD.Console.PrintMessage(f"CodeFeatureProxy.execute for {fp.Label}\n")

        executeCodeFeature(fp)
        return True

    def onChanged(self, fp, prop):
        FreeCAD.Console.PrintMessage(f"Property '{prop}' of {fp.Label} changed.\n")
        
        if prop == "CodeString" or prop == "CodeType" or prop == "GeneratedObjectLabel":
            pass

    def __getstate__(self):
        return None

    def __setstate__(self, state):
        return None