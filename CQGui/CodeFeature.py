# -*- coding: utf-8 -*-
#
# Module for creating and managing 'Code Features' in FreeCAD,
# which are Part::Features driven by Python code (CadQuery or Build123D).

import FreeCAD
import Part

def createCodeFeature(doc, name="CodeFeature"):
    """
    Creates a new 'Code Feature' (a Part::Feature with custom properties for storing code).

    Args:
        doc: The FreeCAD document to add the feature to.
        name (str): The name for the new feature.

    Returns:
        The newly created FreeCAD feature object, or None if creation fails.
    """
    if not doc:
        FreeCAD.Console.PrintError("No active document to add CodeFeature.\n")
        return None

    obj = doc.addObject("Part::Feature", name)
    if not obj:
        FreeCAD.Console.PrintError(f"Failed to create Part::Feature with name {name}.\n")
        return None

    # Add custom properties
    # Property to store the path to the .FCMacro file
    obj.addProperty("App::PropertyFile", "MacroPath", "CodeObject", "Path to the .FCMacro file that generates the shape.")
    

    # Property to store a label for the generated object (used by show_object)
    obj.addProperty("App::PropertyString", "GeneratedObjectLabel", "CodeObject", "Optional label for the object generated by the code.")

    # Initialize properties with default values
    obj.MacroPath = "" # Initialize MacroPath as empty
    obj.GeneratedObjectLabel = name # Default label for the generated part

    FreeCAD.Console.PrintMessage(f"Created CodeFeature: {obj.Name} with Label {obj.Label}\n")
    doc.recompute() # Recompute to make the new object visible and properties available
    return obj

def executeCodeFeature(featureObject):
    """
    Executes the code stored in the CodeFeature and updates its Shape.
    """
    # Ensure MacroPath property exists. If not, try to add it.
    if not hasattr(featureObject, "MacroPath"):
        FreeCAD.Console.PrintWarning(f"Object {featureObject.Name} is missing MacroPath property. Attempting to add it.\n")
        try:
            featureObject.addProperty("App::PropertyFile", "MacroPath", "CodeObject", "Path to the .FCMacro file that generates the shape.")
            FreeCAD.Console.PrintMessage(f"Added MacroPath property to {featureObject.Name}. Please set its value and recompute.\n")
            return 
        except Exception as e:
            FreeCAD.Console.PrintError(f"Could not add MacroPath property to {featureObject.Name}: {e}. Cannot proceed.\n")
            return

    macro_file_path = featureObject.MacroPath
    generated_object_label = featureObject.GeneratedObjectLabel if hasattr(featureObject, "GeneratedObjectLabel") else featureObject.Name

    if not macro_file_path:
        FreeCAD.Console.PrintError(f"MacroPath property is empty for {featureObject.Name}. Please specify a .FCMacro file.\n")
        return
    
    FreeCAD.Console.PrintMessage(f"Executing CodeFeature: {featureObject.Name} from macro: {macro_file_path}\n")

    try:
        import os
        # Attempt to resolve relative paths against the document's directory if the document is saved
        if not os.path.isabs(macro_file_path):
            doc = featureObject.Document
            if doc and doc.FileName:
                doc_dir = os.path.dirname(doc.FileName)
                resolved_path = os.path.join(doc_dir, macro_file_path)
                
                if os.path.exists(resolved_path):
                    FreeCAD.Console.PrintMessage(f"  Resolved relative macro path to: {resolved_path}\n")
                    macro_file_path = resolved_path
                else:
                    FreeCAD.Console.PrintWarning(f"  Macro file '{macro_file_path}' is not absolute. Attempted to resolve relative to document, but '{resolved_path}' not found. Trying to open directly.\n")
            else:
                 FreeCAD.Console.PrintWarning(f"  Macro file '{macro_file_path}' is not absolute and document is not saved/has no path. Trying to open directly.\n")

        with open(macro_file_path, 'r', encoding='utf-8') as f:
            code_from_macro = f.read()
    except FileNotFoundError:
        FreeCAD.Console.PrintError(f"Macro file not found: {macro_file_path} for {featureObject.Name}.\n")
        return
    except Exception as e:
        FreeCAD.Console.PrintError(f"Error reading macro file {macro_file_path} for {featureObject.Name}: {e}\n")
        return


    # Prepare a local scope for exec
    local_scope = {}
    

    # Add a variable to hold the result
    local_scope['result'] = None 

    try:
        # Execute the user's code
        # For safety, consider using a more restricted environment if this code can be arbitrary
        exec(code_from_macro, {"__builtins__": __builtins__}, local_scope)
        
        generated_shape_val = local_scope.get('result')

        if generated_shape_val is None:
            FreeCAD.Console.PrintError("No 'result' variable found in the executed code. Make sure your script assigns the final shape to a variable named 'result'.\n")
            return

        # Convert the resulting CadQuery/Build123D object to a FreeCAD Part.Shape
        # This part reuses logic similar to the existing display.py
        import Part
        from io import BytesIO
        brep_stream = BytesIO()

        # Attempt to export the result.
        # The executed macro is responsible for ensuring 'result' is a CadQuery or Build123D shape.
        exported = False
        try:
            # Try CadQuery export first
            import cadquery as cq_check # Use a different alias to avoid conflict if macro used 'cq'
            if isinstance(generated_shape_val, (cq_check.Workplane, cq_check.Shape)):
                if isinstance(generated_shape_val, cq_check.Workplane):
                    generated_shape_val.val().exportBrep(brep_stream)
                else: # cq_check.Shape
                    generated_shape_val.exportBrep(brep_stream)
                exported = True
                FreeCAD.Console.PrintMessage("  Exported result as CadQuery object.\n")
        except ImportError:
            FreeCAD.Console.PrintWarning("  CadQuery module not found, cannot attempt CadQuery export.\n")
        except Exception as e_cq:
            FreeCAD.Console.PrintWarning(f"  Failed to export as CadQuery object: {e_cq}\n")

        if not exported:
            # Try Build123D export as a fallback
            try:
                from build123d import export_brep as b3d_export_brep
                b3d_export_brep(generated_shape_val, brep_stream)
                exported = True
                FreeCAD.Console.PrintMessage("  Exported result using build123d.export_brep.\n")
            except ImportError:
                FreeCAD.Console.PrintWarning("  build123d.export_brep not found, cannot attempt Build123D export.\n")
            except Exception as e_b3d:
                FreeCAD.Console.PrintError(f"  Failed to export result using build123d.export_brep: {e_b3d}\n")
                # If this also fails, we cannot proceed
                return

        if not exported:
            FreeCAD.Console.PrintError(f"Could not determine how to export the generated shape from macro. Type: {type(generated_shape_val)}\n")
            return
        
        brep_string = brep_stream.getvalue().decode('utf-8')
        if not brep_string:
            FreeCAD.Console.PrintError("Failed to generate BRep string from the code result.\n")
            return
            
        part_shape = Part.Shape()
        part_shape.importBrepFromString(brep_string)

        if part_shape.isNull():
            FreeCAD.Console.PrintError("Resulting Part.Shape is null. Check the code and BRep export.\n")
            return

        featureObject.Shape = part_shape
        if hasattr(featureObject.ViewObject, "ShapeColor"): # Check if ViewObject exists and has ShapeColor
             # You can set default color or expose as property later
            pass # featureObject.ViewObject.ShapeColor = (0.8, 0.8, 0.3) 
        if hasattr(featureObject.ViewObject, "Transparency"):
            pass # featureObject.ViewObject.Transparency = 0

        # Update the label of the feature if a GeneratedObjectLabel was provided
        # The main feature name (obj.Name) is system-managed and should not be changed lightly.
        # The feature label (obj.Label) is user-friendly.
        if generated_object_label:
            featureObject.Label = generated_object_label

        FreeCAD.Console.PrintMessage(f"Successfully updated shape for {featureObject.Name} from code.\n")

    except Exception as e:
        import traceback
        FreeCAD.Console.PrintError(f"Error executing macro '{macro_file_path}' for CodeFeature '{featureObject.Name}':\n------\n{traceback.format_exc()}\n")

    finally:
        if FreeCAD.ActiveDocument: # Ensure doc is still valid
            FreeCAD.ActiveDocument.recompute()

# --- FreeCAD FeaturePython structure (if we were to make it a full FeaturePython object) ---
# This part is more advanced and makes the feature behave more like a native FreeCAD feature,
# with its own icon, properties in the tree, and recomputation logic.
# For now, we are using a simpler approach of adding properties to a Part::Feature.
# If a more integrated solution is needed, this is the direction to go.

class CodeFeatureProxy:
    """
    A proxy class to be used if we make CodeFeature a full FeaturePython object.
    This class handles the logic of the feature, especially recomputation.
    """
    def __init__(self, obj):
        """
        Constructor. obj is the FreeCAD object that this proxy is attached to.
        """
        self.Object = obj
        obj.Proxy = self
        # obj.addProperty("App::PropertyString", "CodeString", "CodeObject", "Python code...").CodeString = "..."
        # obj.addProperty("App::PropertyEnumeration", "CodeType", "CodeObject", "...").CodeType = ["CadQuery", "Build123D"]
        # etc. - properties would be defined here or by the C++ feature if it's a derived one.

    def execute(self, fp):
        """
        Called by FreeCAD when the feature needs to be recomputed.
        fp is the feature object itself (same as self.Object).
        """
        FreeCAD.Console.PrintMessage(f"CodeFeatureProxy.execute for {fp.Label}\n")
        # This is where execute_code_feature would be called
        execute_code_feature(fp)
        return True

    def onChanged(self, fp, prop):
        """
        Called when a property of the feature changes.
        """
        FreeCAD.Console.PrintMessage(f"Property '{prop}' of {fp.Label} changed.\n")
        # If CodeString or CodeType changes, we might want to trigger a recompute.
        # However, FreeCAD usually handles recomputation based on property changes affecting the shape.
        # For non-Output properties, explicit recompute might be needed if they influence the shape.
        if prop == "CodeString" or prop == "CodeType" or prop == "GeneratedObjectLabel":
            # Forcing a recompute might be too aggressive here,
            # FreeCAD's recompute mechanism should pick it up if Shape is touched by execute().
            # self.execute(fp) # Or mark as touched: fp.touch()
            pass


# To make this a full FeaturePython object, you would do something like:
# def create_true_code_feature(doc, name="TrueCodeFeature"):
#    obj = doc.addObject("Part::FeaturePython", name)
#    CodeFeatureProxy(obj) # Attach the proxy
#    obj.ViewObject.Proxy = 0 # Can also have a ViewProviderProxy for custom display
#    # Add properties directly here or ensure CodeFeatureProxy adds them
#    obj.addProperty("App::PropertyString", "CodeString", "CodeObject", "Python code...")
#    obj.CodeString = "import cadquery as cq\nresult = cq.Workplane('XY').box(1,2,3).val()"
#    obj.addProperty("App::PropertyEnumeration", "CodeType", "CodeObject", "Code Type")
#    obj.CodeType = ["CadQuery", "Build123D"]
#    obj.CodeType = "CadQuery"
#    doc.recompute()
#    return obj

# This file needs to be imported by the workbench's InitGui.py to register commands
# and potentially by Init.py if it's defining non-GUI aspects of features.
