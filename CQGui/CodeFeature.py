# -*- coding: utf-8 -*-
#
# Module for creating and managing 'Code Features' in FreeCAD,
# which are Part::Features driven by Python code (CadQuery or Build123D).

import FreeCAD
import Part

def createCodeFeature(doc, name="CodeFeature"):
    """
    Creates a new 'Code Feature' (a Part::Feature with custom properties for storing code).

    Args:
        doc: The FreeCAD document to add the feature to.
        name (str): The name for the new feature.

    Returns:
        The newly created FreeCAD feature object, or None if creation fails.
    """
    if not doc:
        FreeCAD.Console.PrintError("No active document to add CodeFeature.\n")
        return None

    obj = doc.addObject("Part::FeaturePython", name)
    if not obj:
        FreeCAD.Console.PrintError(f"Failed to create Part::Feature with name {name}.\n")
        return None

    # Add custom properties
    # Property for the macro filename
    obj.addProperty("App::PropertyString", "MacroFilename", "CodeObject", "Filename of the .FCMacro (e.g., MyMacro.FCMacro).")
    # Property for the macro directory
    obj.addProperty("App::PropertyPath", "MacroDir", "CodeObject", "Directory containing the macro file. Leave empty to use document's dir or user macro dir.")
    

    # Property to store a label for the generated object (used by show_object)
    obj.addProperty("App::PropertyString", "GeneratedObjectLabel", "CodeObject", "Optional label for the object generated by the code.")

    # Initialize properties with default values
    obj.MacroFilename = ""
    try:
        defaultMacroUserPath = FreeCAD.ParamGet("User parameter:BaseApp/Preferences/Macro").GetString("MacroPath")
        obj.MacroDir = defaultMacroUserPath
    except Exception:
        obj.MacroDir = "" # Default to empty if preference not found
    obj.GeneratedObjectLabel = name # Default label for the generated part

    FreeCAD.Console.PrintMessage(f"Created CodeFeature: {obj.Name} with Label {obj.Label}\n")
    CodeFeatureProxy(obj)
    if FreeCAD.GuiUp:
        ViewProviderCodeFeature(obj.ViewObject)
    doc.recompute() # Recompute to make the new object visible and properties available
    return obj

# todo: convert variables in here to be camelCase
def executeCodeFeature(featureObject):
    """
    Executes the macro specified by MacroFilename and MacroDir CodeFeature properties 
    and updates the feature's Shape.
    """
    # Ensure MacroFilename and MacroDir properties exist. Add with defaults if not.
    if not hasattr(featureObject, "MacroFilename"):
        try:
            featureObject.addProperty("App::PropertyString", "MacroFilename", "CodeObject", "Filename of the .FCMacro (e.g., MyMacro.FCMacro).")
            featureObject.MacroFilename = "" # Initialize
            FreeCAD.Console.PrintWarning(f"Added missing MacroFilename property to {featureObject.Name}. Please set its value.\n")
        except Exception as e:
            FreeCAD.Console.PrintError(f"Could not add MacroFilename property to {featureObject.Name}: {e}\n")
            return # Cannot proceed
            
    if not hasattr(featureObject, "MacroDir"):
        try:
            featureObject.addProperty("App::PropertyPath", "MacroDir", "CodeObject", "Directory containing the macro file. Leave empty or set to user/doc default.")
            try: # Try to set a sensible default
                defaultMacroUserPath = FreeCAD.ParamGet("User parameter:BaseApp/Preferences/Macro").GetString("MacroPath")
                featureObject.MacroDir = defaultMacroUserPath
            except:
                featureObject.MacroDir = "" # Default to empty if preference not found
            FreeCAD.Console.PrintWarning(f"Added missing MacroDir property to {featureObject.Name}. Initialized to '{featureObject.MacroDir}'. Please verify/set its value.\n")
        except Exception as e:
            FreeCAD.Console.PrintError(f"Could not add MacroDir property to {featureObject.Name}: {e}\n")
            return # Cannot proceed

    macroFilename = featureObject.MacroFilename
    macroDir = featureObject.MacroDir # This is a PropertyPath, should be a string dir path
    generatedObjectLabel = featureObject.GeneratedObjectLabel if hasattr(featureObject, "GeneratedObjectLabel") else featureObject.Name

    if not macroFilename:
        FreeCAD.Console.PrintError(f"MacroFilename property is empty for {featureObject.Name}. Please specify a .FCMacro filename.\n")
        return

    # Ensure os is imported for path operations
    import os 
    fullMacroPath = ""

    # 1. If macroFilename is an absolute path, use it directly.
    if os.path.isabs(macroFilename):
        fullMacroPath = macroFilename
        FreeCAD.Console.PrintMessage(f"Interpreting MacroFilename '{macroFilename}' as an absolute path.\n")
    # 2. Else if MacroDir is specified and absolute, combine them.
    elif macroDir and os.path.isabs(str(macroDir)): # PropertyPath might not be string directly
        fullMacroPath = os.path.join(str(macroDir), macroFilename)
        FreeCAD.Console.PrintMessage(f"Using specified absolute MacroDir '{str(macroDir)}' + Filename: {fullMacroPath}\n")
    # 3. Else if MacroDir is specified (but may be relative or just a hint)
    elif macroDir: 
        # For App::PropertyPath, it should ideally be an absolute path if set by user via dialog.
        # If it's relative, its interpretation can be tricky.
        # We'll assume os.path.join can handle it if it's a valid relative path string.
        fullMacroPath = os.path.join(str(macroDir), macroFilename)
        FreeCAD.Console.PrintMessage(f"Using specified MacroDir '{str(macroDir)}' (may be relative) + Filename: {fullMacroPath}\n")
    
    # 4. Fallbacks if path not yet resolved or if above constructions don't exist
    # Check existence after primary construction attempts
    if fullMacroPath and os.path.exists(fullMacroPath):
        exec(open(fullMacroPath).read())
# --- FreeCAD FeaturePython structure (if we were to make it a full FeaturePython object) ---
# This part is more advanced and makes the feature behave more like a native FreeCAD feature,
# with its own icon, properties in the tree, and recomputation logic.

class ViewProviderCodeFeature:
    def __init__(self, vobj):
        vobj.Proxy = self
        self.Object = vobj.Object

    def attach(self, vobj):
        self.Object = vobj.Object
        self.ViewObject = vobj
        return

    def updateData(self, fp, prop):
        pass

    def getDisplayModes(self, obj):
        modes = ["Shaded", "Wireframe", "Flat Lines", "Points"]
        return modes

    def setDisplayMode(self, mode):
        return mode

    def claimChildren(self):
        if hasattr(self.Object, "Shape") and self.Object.Shape and not self.Object.Shape.isNull():
            return [self.Object.Shape]
        return []

    def getIcon(self):
        return ""

# For now, we are using a simpler approach of adding properties to a Part::Feature.
# If a more integrated solution is needed, this is the direction to go.

class CodeFeatureProxy:
    """
    A proxy class to be used if we make CodeFeature a full FeaturePython object.
    This class handles the logic of the feature, especially recomputation.
    """
    def __init__(self, obj):
        """
        Constructor. obj is the FreeCAD object that this proxy is attached to.
        """
        self.Object = obj
        obj.Proxy = self
        # obj.addProperty("App::PropertyString", "CodeString", "CodeObject", "Python code...").CodeString = "..."
        # obj.addProperty("App::PropertyEnumeration", "CodeType", "CodeObject", "...").CodeType = ["CadQuery", "Build123D"]
        # etc. - properties would be defined here or by the C++ feature if it's a derived one.

    def execute(self, fp):
        """
        Called by FreeCAD when the feature needs to be recomputed.
        fp is the feature object itself (same as self.Object).
        """
        FreeCAD.Console.PrintMessage(f"CodeFeatureProxy.execute for {fp.Label}\n")
        # This is where execute_code_feature would be called
        execute_code_feature(fp)
        return True

    def onChanged(self, fp, prop):
        """
        Called when a property of the feature changes.
        """
        FreeCAD.Console.PrintMessage(f"Property '{prop}' of {fp.Label} changed.\n")
        # If CodeString or CodeType changes, we might want to trigger a recompute.
        # However, FreeCAD usually handles recomputation based on property changes affecting the shape.
        # For non-Output properties, explicit recompute might be needed if they influence the shape.
        if prop == "CodeString" or prop == "CodeType" or prop == "GeneratedObjectLabel":
            # Forcing a recompute might be too aggressive here,
            # FreeCAD's recompute mechanism should pick it up if Shape is touched by execute().
            # self.execute(fp) # Or mark as touched: fp.touch()
            pass


# To make this a full FeaturePython object, you would do something like:
# def create_true_code_feature(doc, name="TrueCodeFeature"):
#    obj = doc.addObject("Part::FeaturePython", name)
#    CodeFeatureProxy(obj) # Attach the proxy
#    obj.ViewObject.Proxy = 0 # Can also have a ViewProviderProxy for custom display
#    # Add properties directly here or ensure CodeFeatureProxy adds them
#    obj.addProperty("App::PropertyString", "CodeString", "CodeObject", "Python code...")
#    obj.CodeString = "import cadquery as cq\nresult = cq.Workplane('XY').box(1,2,3).val()"
#    obj.addProperty("App::PropertyEnumeration", "CodeType", "CodeObject", "Code Type")
#    obj.CodeType = ["CadQuery", "Build123D"]
#    obj.CodeType = "CadQuery"
#    doc.recompute()
#    return obj

# This file needs to be imported by the workbench's InitGui.py to register commands
# and potentially by Init.py if it's defining non-GUI aspects of features.
